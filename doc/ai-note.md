1. 数学基础
   * 微积分 
    1. 函数
       * 定义域D（函数的x范围） 值域R（函数的值）。
       * 有界性：有界（有一个值可以大于函数的最大值或小于最小值） 无界（与有界相反）；
       * 单调性：在一个区间上，值一直增加（单调增函数），值一直减小（单调减函数）
       * 奇偶性：偶函数（关于Y轴对称）奇函数（关于原点对称）
       * 周期性：
       * 反函数：如果x与y关于某种对应关系f(x)相对应，y=f(x)，则y=f(x)的反函数为x=f-1(y)。存在反函数（默认为单值函数）的条件是原函数必须是一一对应的
       * 复合函数： 
       * 幂函数：y=x²
       * 指数函数：y=e的x方
       * 对数函数：y=loge的x方 loge的e方=1 loge的e分之一=-1
       * 三角函数：sinx cosx tanx cotx=1/tanx=cosx/sinx secx=1/cosx（正割） cscx=1/sinx（余割） arcsinx(反正弦函数) arccosx(反余弦函数) arctanx(反tan函数) arccotx(反cot函数)
       * 函数极限：邻域U(x)、去心邻域; 任给一可搜隆>0, 存在徳塔= , 0 < | x-极限 | < 徳塔，| f(x) - 极限 | < 一可搜隆。左极限与右极限相等时，函数极限才存在。函数极限具有唯一性、局部有界性、局部保号性。
       * 无穷小量是0，无穷大量是无穷大；2个无穷小的和是无穷小，有限个无穷小的和是无穷小，有界函数与无穷小的乘积是无穷小，有限个无穷小相乘是无穷小，两个函数极限的计算符合四则运算
       * 夹逼准则：y(x)<=f(x)<=h(x), 如果y(x)和h(x)的极限是A，则f(x)的极限也为A。
       * 第一重要极限：lim x=>0 sin(x)/x = 1 lim x=>0 x/sin(x) = 1。第二重要极限：lim n=>无穷 (1+1\n)n次方 = e  lim x=>无穷 (1+x)1/x次方 = e
   * 线性代数
   * 统计与概率
2. 数据科学基础
   * 学习数据科学的定义、应用场景和常见任务，如数据清洗、数据探索、数据分析、数据可视化等
   * 推荐阅读《Python 数据科学手册》（Jake VanderPlas 著），结合实际案例理解数据科学的基本概念
   * 学习使用 Pandas 和 NumPy 进行数据清洗、预处理和转换
3. 机器学习
   * 学习监督学习、无监督学习、半监督学习和强化学习的基本概念。
   * 掌握常见的机器学习任务，如分类、回归、聚类等。
   * 推荐阅读《机器学习实战》（Peter Harrington 著），结合实际案例理解机器学习的基本概念。
   * 掌握常见的机器学习算法，如线性回归、逻辑回归、决策树、支持向量机（SVM）、K-Means 聚类等。
   * 使用 Scikit-Learn 等库实现这些算法，解决实际问题。
   * 学习模型评估指标，如准确率、召回率、F1 分数、ROC 曲线等。
   * 掌握特征工程的基本方法，如特征选择、特征提取、归一化等。
   * 学习更复杂的算法，如随机森林、梯度提升树（GBDT）、XGBoost 等。
4. 深度学习
   * 阅读经典的入门书籍，如《深度学习》（Ian Goodfellow 等著）的前几章，了解神经网络的基本概念、激活函数、损失函数等。
   * 观看在线课程，如吴恩达的《深度学习专项课程》（Coursera），系统地学习神经网络的基础知识。
   * 学习多层感知机（MLP）、卷积神经网络（CNN）和循环神经网络（RNN）的基本原理和应用场景。
   * 使用深度学习框架（如 TensorFlow 或 PyTorch）实现简单的神经网络模型，例如手写数字识别（MNIST 数据集）。
5. python基础与pytorchAI框架
6. prompt提示词工程
   * 明确任务目标
   * 提供清晰指示
   * 添加示例
   * 角色扮演：让模型模拟特定角色
   * 思维链：推理步骤引导模型
   * 限制条件：明确排除不希望出现的内容
   * 多轮对话优化
   * 零样本提示
   * 单样本提示
   * 少样本提示
   * 系统提示与角色提示
   * 自动提示工程
7. RAG应用搭建
   RAG应用：检索（Retrieval）：当用户提出问题时，从外部知识库（如文档、数据库等）中检索与问题最相关的片段或数据。增强（Augmented Generation）：将检索到的信息与用户输入的问题结合，输入到大语言模型（如GPT、T5等），生成响应。
   * 搭建环境：conda搭建python运行环境，使用（LlamaIndex: 适合RAG，LangChain：适合Agent）框架搭建RAG应用
   * 收集数据并通过对文本清洗（移除特殊符号、标点符号、停用词、多余空格，统一大小写，分词）和分割（按句子、段落或固定长度）的方式构建知识库
   * 搭建向量数据库（开源例如：Chroma、Milvus、Qdrant），将数据转换为向量（嵌入，通过嵌入模型如：Word2Vec、Sentence-BERT）并持久化
   * 基于LangChain等语言模型框架，根据输入对数据库查询
   * 通过大模型对查询结果整理和调整，搭建http请求，搭建前端应用
8. Agent应用搭建
   Agent应用，也称为智能体应用，是一种能够自主执行任务、与用户交互并提供智能化服务的应用程序。它结合了人工智能（AI）、自然语言处理（NLP）、机器学习（ML）和自动化技术，使应用能够理解用户需求、调用外部工具和API，并生成智能响应。
   * 规划Agent应用的整体架构，包括前端界面、后端服务和Agent模块等。前端负责与用户交互，后端处理业务逻辑，Agent模块则负责核心的智能处理。
   * 选择开发平台和工具，根据需求选择合适的开发平台和工具
   * 为Agent编写清晰的系统提示词，以指导其行为和响应方式。例如，在旅游助手应用中，提示词可以是“你是一个专业的旅游顾问，能够根据用户的需求提供旅行建议和信息”。根据应用场景，集成必要的工具和API以扩展Agent的能力。
   * 在开发平台上实现Agent的业务逻辑，包括：定义工作流：设置Agent的工作流程，包括如何接收用户输入、调用工具和生成响应。配置模型：选择合适的语言模型，并根据* 需要进行微调或优化。处理用户输入：编写代码以解析用户输入，并根据输入内容调用相应的函数或工具。
   * 测试与优化：尝试多agent、prompt工程以及微调模型
   * ​​工具集成（MCP协议）​​使用MCP Server标准化接入外部工具（如搜索、数据库）：
   ```py
     from mcp_client import MCPClient, load_mcp_tools
     
     async def init_tools():
     # 连接Tavily搜索的MCP Server
     tools = await load_mcp_tools(
      server_config={"command": "npx", "args": ["@tavily/mcp-server"]}
     )
      return tools
   ```
   ​​Agent构建与任务执行​​
   ```py
   from langchain.agents import create_react_agent
   from langchain_openai import ChatOpenAI

   llm = ChatOpenAI(model="gpt-4") # 可替换各种模型
   tools = await init_tools()  # 加载MCP工具

   agent = create_react_agent(llm, tools, prompt="你是一个专业的xx助手")
   response = agent.run("查询当天的天气") # 自定义提示词
   ```
9. Vibe Coding
   当前软件开发领域一种新兴的、由人工智能驱动的范式。它标志着开发者角色的一次根本性转变：从逐行编写代码的实现者，转变为通过自然语言描述意图来指导AI生成代码的“指导者”或“架构师”。
   
   核心在于“意图驱动”。你可以不再需要精通特定编程语言的语法和细节，而是专注于用自然语言清晰地表达你想要实现的功能、逻辑或目标（即所谓的“氛围”或“感觉”），然后由大型语言模型（如 GPT-4、Claude 等）作为执行代理，将你的意图转化为可运行的代码。

   主要适用的场景：快速的原型搭建、语言学习和实践
10. Spec-driven Development(SSD)
   规范驱动编程，是一种在AI时代兴起的软件开发范式，其核心思想是“定义先行，实现后行”。它强调在编写具体代码之前，首先创建一份结构清晰、机器可读的“规范”文档，并以此作为唯一的“事实来源”，驱动AI辅助工具生成高质量的代码。

   以GitHub Spec Kit为例
   * 定义规范(/specify)：用自然语言清晰描述要构建的功能
   * 制定技术计划(/plan)：基于已确定的规范来选择具体的技术栈和架构
   * 拆解任务（/tasks）：AI将技术计划自动拆解成一系列小而具体的开发任务，并明确任务之间的依赖关系
   * 实现代码(/implement)：AI编码代理根据任务列表，一步步地生成符合规范的代码、测试用例以及相关文档
   prompt示例：
      我想实现 [功能名称: 比如 用户登录]。

      请运行 specify 流程，并注意以下细节：
         1. **上下文**：这个功能主要涉及 [文件A], [文件B] 和 [数据库Schema文件]。
         2. **交互逻辑**：当用户 [操作] 时，应该发生 [结果]。如果失败，应该 [错误处理]。
         3. **技术约束**：
            - 必须使用 [特定技术/库]。
            - 必须符合 [项目宪法] 中的 [某条规则]（例如：必须有单元测试）。
         4. **边缘情况**：请考虑 [比如：网络断开/并发请求] 的情况。

      请生成 Spec md 文件。
11. Harness Engineering (AI利用工程)
   一种通过结构化的人类指导层来驱动AI编码智能体进行大规模软件开发的方法
   1. 结构化文档作为"单一事实来源"
   2. 声明式提示（Declarative Prompts）
   3. 自动化评估与迭代循环
